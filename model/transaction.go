// Code generated by go-swagger; DO NOT EDIT.

package model

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Transaction transaction
//
// swagger:model Transaction
type Transaction struct {

	// assigned entities
	AssignedEntities []*AssignedEntity `json:"AssignedEntities"`

	// b i c
	BIC string `json:"BIC,omitempty"`

	// b i c counter party
	BICCounterParty string `json:"BICCounterParty,omitempty"`

	// bank account ID
	BankAccountID int32 `json:"BankAccountID,omitempty"`

	// bank account transaction ID
	BankAccountTransactionID int32 `json:"BankAccountTransactionID,omitempty"`

	// bank name
	BankName string `json:"BankName,omitempty"`

	// bank reference
	BankReference string `json:"BankReference,omitempty"`

	// bank transaction code
	BankTransactionCode string `json:"BankTransactionCode,omitempty"`

	// client reference
	ClientReference string `json:"ClientReference,omitempty"`

	// coda file ID
	// Example: 00000000-0000-0000-0000-000000000000
	// Format: uuid
	CodaFileID strfmt.UUID `json:"CodaFileID,omitempty"`

	// coda source
	CodaSource string `json:"CodaSource,omitempty"`

	// currency
	Currency string `json:"Currency,omitempty"`

	// description
	Description string `json:"Description,omitempty"`

	// document Id
	DocumentID int32 `json:"DocumentId,omitempty"`

	// external provider ID
	ExternalProviderID string `json:"ExternalProviderID,omitempty"`

	// external provider t c
	ExternalProviderTC string `json:"ExternalProviderTC,omitempty"`

	// free message
	FreeMessage string `json:"FreeMessage,omitempty"`

	// i b a n
	IBAN string `json:"IBAN,omitempty"`

	// i b a n counter party
	IBANCounterParty string `json:"IBANCounterParty,omitempty"`

	// name counter party
	NameCounterParty string `json:"NameCounterParty,omitempty"`

	// note
	Note string `json:"Note,omitempty"`

	// proprietary bank transaction code
	ProprietaryBankTransactionCode string `json:"ProprietaryBankTransactionCode,omitempty"`

	// total amount
	TotalAmount float64 `json:"TotalAmount,omitempty"`

	// transaction type
	TransactionType string `json:"TransactionType,omitempty"`

	// value date
	// Format: date-time
	ValueDate *strfmt.DateTime `json:"ValueDate,omitempty"`
}

// Validate validates this transaction
func (m *Transaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssignedEntities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCodaFileID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Transaction) validateAssignedEntities(formats strfmt.Registry) error {
	if swag.IsZero(m.AssignedEntities) { // not required
		return nil
	}

	for i := 0; i < len(m.AssignedEntities); i++ {
		if swag.IsZero(m.AssignedEntities[i]) { // not required
			continue
		}

		if m.AssignedEntities[i] != nil {
			if err := m.AssignedEntities[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AssignedEntities" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("AssignedEntities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Transaction) validateCodaFileID(formats strfmt.Registry) error {
	if swag.IsZero(m.CodaFileID) { // not required
		return nil
	}

	if err := validate.FormatOf("CodaFileID", "body", "uuid", m.CodaFileID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Transaction) validateValueDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ValueDate) { // not required
		return nil
	}

	if err := validate.FormatOf("ValueDate", "body", "date-time", m.ValueDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this transaction based on the context it is used
func (m *Transaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAssignedEntities(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Transaction) contextValidateAssignedEntities(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AssignedEntities); i++ {

		if m.AssignedEntities[i] != nil {

			if swag.IsZero(m.AssignedEntities[i]) { // not required
				return nil
			}

			if err := m.AssignedEntities[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("AssignedEntities" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("AssignedEntities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Transaction) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Transaction) UnmarshalBinary(b []byte) error {
	var res Transaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
